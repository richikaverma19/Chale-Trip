chaletrip-backend/
├── config/
│   ├── db.js                # Database connection
│   └── socket.js            # WebSocket configuration
├── controllers/
│   ├── authController.js
│   ├── bookingController.js
│   ├── destinationController.js
│   ├── notificationController.js
│   ├── tripController.js
│   └── adminController.js
├── middleware/
│   ├── auth.js              # Authentication middleware
│   ├── admin.js             # Admin check middleware
│   └── errorHandler.js      # Custom error handling
├── models/
│   ├── User.js
│   ├── Destination.js
│   ├── Trip.js
│   ├── Booking.js
│   ├── Service.js
│   ├── Notification.js
│   └── Review.js
├── routes/
│   ├── auth.js
│   ├── destinations.js
│   ├── trips.js
│   ├── bookings.js
│   ├── services.js
│   ├── notifications.js
│   ├── admin.js
│   └── pdf.js
├── services/
│   ├── emailService.js
│   ├── notificationService.js
│   ├── pdfService.js
│   └── mapService.js
├── utils/
│   ├── helpers.js
│   ├── cache.js             # Redis caching
│   └── validators.js
├── .env
├── app.js                   # Main application
└── server.js                # HTTP/WebSocket server






config/db.js
const mongoose = require('mongoose');
const logger = require('../utils/logger');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true
    });
    logger.info('MongoDB connected successfully');
  } catch (err) {
    logger.error('MongoDB connection error:', err);
    process.exit(1);
  }
};

module.exports = connectDB;



config/socket.js
const Notification = require('../models/Notification');
const logger = require('../utils/logger');

module.exports = (io) => {
  io.on('connection', (socket) => {
    logger.info(`New client connected: ${socket.id}`);

    socket.on('join-user-room', async (userId) => {
      socket.join(`user-${userId}`);
      const unreadCount = await Notification.countDocuments({
        userId,
        read: false
      });
      io.to(`user-${userId}`).emit('unread-count', unreadCount);
    });

    socket.on('join-admin-room', () => {
      socket.join('admin-room');
    });

    socket.on('disconnect', () => {
      logger.info(`Client disconnected: ${socket.id}`);
    });
  });

  global.io = io;
};





controllers/authController.js
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const { sendEmail } = require('../services/emailService');
const logger = require('../utils/logger');

exports.register = async (req, res) => {
  try {
    const { email, password, username } = req.body;
    
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);

    const user = new User({
      username,
      email,
      passwordHash,
      salt
    });

    await user.save();

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {
      expiresIn: '24h'
    });

    // Send welcome email
    await sendEmail({
      email: user.email,
      subject: 'Welcome to Chaletrip',
      template: 'welcome',
      data: { name: user.username }
    });

    res.status(201).json({ token, user });
  } catch (err) {
    logger.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });

    if (!user || !(await bcrypt.compare(password, user.passwordHash))) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {
      expiresIn: '24h'
    });

    res.json({ token, user });
  } catch (err) {
    logger.error(err);
    res.status(500).json({ message: 'Server error' });
  }
}; 





controllers/bookingController.js
const Booking = require('../models/Booking');
const Trip = require('../models/Trip');
const { emitNotification } = require('../services/notificationService');
const logger = require('../utils/logger');

exports.createBooking = async (req, res) => {
  try {
    const { tripId, items, paymentMethod } = req.body;
    const userId = req.user.id;

    const trip = await Trip.findById(tripId);
    if (!trip) {
      return res.status(404).json({ message: 'Trip not found' });
    }

    const totalAmount = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);

    const booking = new Booking({
      userId,
      tripId,
      items,
      totalAmount,
      paymentMethod,
      paymentStatus: 'paid'
    });

    await booking.save();

    // Emit real-time notification
    emitNotification(global.io, userId, {
      type: 'booking',
      message: `Your booking #${booking._id} is confirmed`,
      bookingId: booking._id
    });

    res.status(201).json(booking);
  } catch (err) {
    logger.error(err);
    res.status(500).json({ message: 'Server error' });
  }
};




middleware/auth.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const logger = require('../utils/logger');

exports.auth = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ message: 'No token provided' });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-passwordHash -salt');

    if (!user) {
      return res.status(401).json({ message: 'Invalid token' });
    }

    req.user = user;
    next();
  } catch (err) {
    logger.error(err);
    res.status(401).json({ message: 'Not authorized' });
  }
};

exports.admin = async (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ message: 'Admin access required' });
  }
  next();
};



models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  passwordHash: { type: String, required: true },
  salt: { type: String, required: true },
  role: { type: String, enum: ['user', 'admin', 'guide'], default: 'user' },
  profile: {
    firstName: String,
    lastName: String,
    avatar: String,
    preferences: [String]
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

UserSchema.methods.validatePassword = async function(password) {
  return await bcrypt.compare(password, this.passwordHash);
};

module.exports = mongoose.model('User', UserSchema);



models/Booking.js
const mongoose = require('mongoose');

const BookingItemSchema = new mongoose.Schema({
  type: { type: String, enum: ['accommodation', 'activity', 'transport'], required: true },
  itemId: { type: mongoose.Schema.Types.ObjectId, required: true },
  name: { type: String, required: true },
  date: { type: Date, required: true },
  quantity: { type: Number, default: 1 },
  price: { type: Number, required: true }
});

const BookingSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  tripId: { type: mongoose.Schema.Types.ObjectId, ref: 'Trip', required: true },
  items: [BookingItemSchema],
  totalAmount: { type: Number, required: true },
  paymentStatus: { type: String, enum: ['pending', 'paid', 'failed'], default: 'pending' },
  paymentMethod: { type: String, required: true },
  transactionId: String,
  bookingDate: { type: Date, default: Date.now },
  status: { type: String, enum: ['confirmed', 'cancelled', 'completed'], default: 'confirmed' }
}, { timestamps: true });

module.exports = mongoose.model('Booking', BookingSchema);




routes/auth.js
const express = require('express');
const router = express.Router();
const {
  register,
  login
} = require('../controllers/authController');

router.post('/register', register);
router.post('/login', login);

module.exports = router;



routes/bookings.js
const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const {
  createBooking,
  getBooking,
  getUserBookings
} = require('../controllers/bookingController');

router.post('/', auth, createBooking);
router.get('/:id', auth, getBooking);
router.get('/user/:userId', auth, getUserBookings);

module.exports = router;




services/emailService.js
const nodemailer = require('nodemailer');
const sgMail = require('@sendgrid/mail');
const ejs = require('ejs');
const fs = require('fs');
const path = require('path');
const logger = require('../utils/logger');

const renderTemplate = async (templateName, data) => {
  const templatePath = path.join(__dirname, `../templates/emails/${templateName}.ejs`);
  const template = fs.readFileSync(templatePath, 'utf-8');
  return ejs.render(template, data);
};

exports.sendEmail = async ({ email, subject, template, data }) => {
  try {
    const html = await renderTemplate(template, data);

    if (process.env.NODE_ENV === 'production') {
      sgMail.setApiKey(process.env.SENDGRID_API_KEY);
      await sgMail.send({
        to: email,
        from: process.env.EMAIL_FROM,
        subject,
        html
      });
    } else {
      const transporter = nodemailer.createTransport({
        host: process.env.MAILTRAP_HOST,
        port: process.env.MAILTRAP_PORT,
        auth: {
          user: process.env.MAILTRAP_USER,
          pass: process.env.MAILTRAP_PASS
        }
      });

      await transporter.sendMail({
        from: `"Chaletrip" <${process.env.EMAIL_FROM}>`,
        to: email,
        subject,
        html
      });
    }

    logger.info(`Email sent to ${email}`);
  } catch (err) {
    logger.error('Email sending failed:', err);
    throw err;
  }
};




utils/logger.js
const { createLogger, format, transports } = require('winston');
const { combine, timestamp, printf, colorize } = format;

const logFormat = printf(({ level, message, timestamp }) => {
  return `${timestamp} [${level}]: ${message}`;
});

const logger = createLogger({
  level: 'info',
  format: combine(
    colorize(),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    logFormat
  ),
  transports: [
    new transports.Console(),
    new transports.File({ filename: 'logs/error.log', level: 'error' }),
    new transports.File({ filename: 'logs/combined.log' })
  ]
});

module.exports = logger;





app.js
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const connectDB = require('./config/db');
const errorHandler = require('./middleware/errorHandler');
const logger = require('./utils/logger');

// Connect to database
connectDB();

const app = express();

// Middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL,
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 1000
});
app.use(limiter);

// Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/bookings', require('./routes/bookings'));
// Add other routes...

// Error handling
app.use(errorHandler);

// Health check
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'OK' });
});

module.exports = app;



server.js
const http = require('http');
const socketio = require('socket.io');
const app = require('./app');
const socketConfig = require('./config/socket');
const logger = require('./utils/logger');

const server = http.createServer(app);
const io = socketio(server, {
  cors: {
    origin: process.env.FRONTEND_URL,
    methods: ["GET", "POST"]
  }
});

// Configure sockets
socketConfig(io);

const PORT = process.env.PORT || 5000;

server.listen(PORT, () => {
  logger.info(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});



